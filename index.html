<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Titan's Circuit - Hexagonal Strategy Game</title>
    <style>
      :root {
        --red-color: #ff6b6b;
        --blue-color: #4d96ff;
        --gold-color: gold;
        --dark-color: #333;
        --light-color: #f0f0f0;
        --white: #fff;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: #292d35;
        color: var(--dark-color);
        min-height: 100vh;
        padding: 20px;
      }

      h1 {
        margin: 20px 0;
        color: var(--dark-color);
        text-align: center;
      }

      .game-container {
        position: relative;
        height: min-content;
        width: min-content;
        margin: 0 auto;
      }

      .hex-grid {
        position: relative;
        width: 100%;
        height: 300px;
        margin-top: 30px;
        margin-bottom: 30px;
      }

      .hex-circuit {
        position: relative;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        opacity: 0.9;
      }

      .hex-circuit.outer {
        width: 400px;
        height: 400px;
      }

      .hex-circuit.middle {
        width: 260px;
        height: 260px;
      }

      .hex-circuit.inner {
        width: 120px;
        height: 120px;
      }

      .hex-node {
        position: absolute;
        width: 32px;
        height: 32px;
        border-radius: 50%;
        background-color: #454544;
        border: 3px solid #fdfdfc;
        transform: translate(-50%, -50%);
        cursor: pointer;
        z-index: 10;
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        transition: all 0.3s ease;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }

      .hex-node.red {
        background-color: var(--red-color);
        color: var(--white);
      }

      .hex-node.blue {
        background-color: var(--blue-color);
        color: var(--white);
      }

      .hex-node.highlight {
        box-shadow: 0 0 0 4px rgba(255, 215, 0, 0.7);
      }

      .hex-node.selected {
        box-shadow: 0 0 0 6px rgba(255, 255, 255, 0.9);
        transform: translate(-50%, -50%) scale(1.1);
      }

      .hex-edge {
        position: absolute;
        background-color: #fdfdfc;
        transform-origin: 0 0;
        z-index: 1;
        height: 3px;
        transition: all 0.3s ease;
      }

      .edge-weight {
        position: absolute;
        font-size: 15px;
        color: #fdfdfc;
        font-weight: bold;
        transform: translate(-50%, -50%);
        padding: 2px 5px;
        border-radius: 10px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        z-index: 2;
      }

      .controlled-edge.red {
        background-color: var(--red-color);
        height: 5px;
        z-index: 2;
      }

      .controlled-edge.blue {
        background-color: var(--blue-color);
        height: 5px;
        z-index: 2;
      }

      .game-info {
        display: flex;
        justify-content: space-between;
        width: 100%;
        max-width: 650px;
        margin-bottom: 20px;
        background-color: var(--white);
        padding: 15px;
        border-radius: 10px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      }

      .player-info {
        padding: 15px;
        border-radius: 8px;
        text-align: center;
        width: 48%;
        transition: all 0.3s ease;
      }

      .player-info.active {
        transform: translateY(-5px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      }

      .player-info.red {
        background-color: rgba(255, 107, 107, 0.1);
        border: 2px solid var(--red-color);
      }

      .player-info.blue {
        background-color: rgba(77, 150, 255, 0.1);
        border: 2px solid var(--blue-color);
      }

      .player-info h2 {
        margin-bottom: 10px;
        color: var(--dark-color);
      }

      .timer {
        font-size: 24px;
        font-weight: bold;
        margin: 10px 0;
        font-family: "Courier New", monospace;
      }

      .score {
        font-size: 20px;
        margin: 5px 0;
      }

      .titan-count {
        font-size: 16px;
        margin: 5px 0;
      }

      .game-status {
        width: 100%;
        max-width: 650px;
        margin: 15px 0;
        font-size: 18px;
        font-weight: bold;
        padding: 15px;
        background-color: var(--white);
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        text-align: center;
        min-height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .controls {
        display: flex;
        gap: 10px;
        width: 100%;
        max-width: 650px;
        margin-top: 10px;
        flex-wrap: wrap;
        justify-content: center;
      }

      button {
        padding: 12px 24px;
        background-color: #4caf50;
        color: var(--white);
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
        transition: all 0.3s ease;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      button:hover {
        background-color: #45a049;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      button:active {
        transform: translateY(0);
      }

      button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      button.secondary {
        background-color: #f39c12;
      }

      button.secondary:hover {
        background-color: #e67e22;
      }

      button.danger {
        background-color: #e74c3c;
      }

      button.danger:hover {
        background-color: #c0392b;
      }

      .move-history {
        width: 100%;
        max-width: 650px;
        margin-top: 20px;
        background-color: var(--white);
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        max-height: 200px;
        overflow-y: auto;
      }

      .move-history h3 {
        margin-bottom: 10px;
        text-align: center;
      }

      .move-item {
        padding: 8px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
      }

      .move-item:last-child {
        border-bottom: none;
      }

      .move-player {
        font-weight: bold;
      }

      .move-player.red {
        color: var(--red-color);
      }

      .move-player.blue {
        color: var(--blue-color);
      }

      /* Animations */
      @keyframes pulse {
        0% {
          transform: translate(-50%, -50%) scale(1);
        }
        50% {
          transform: translate(-50%, -50%) scale(1.1);
        }
        100% {
          transform: translate(-50%, -50%) scale(1);
        }
      }

      .pulse {
        animation: pulse 1.5s infinite;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .fade-in {
        animation: fadeIn 0.5s ease-in;
      }

      /* Mobile responsiveness */
      @media (max-width: 700px) {
        .hex-circuit.outer {
          width: 500px;
          height: 500px;
        }

        .hex-circuit.middle {
          width: 200px;
          height: 200px;
        }

        .hex-circuit.inner {
          width: 100px;
          height: 100px;
        }

        .hex-node {
          width: 28px;
          height: 28px;
          font-size: 12px;
        }

        .game-info {
          flex-direction: column;
          gap: 10px;
        }

        .player-info {
          width: 100%;
        }

        .controls button {
          padding: 10px 15px;
          font-size: 14px;
        }
      }

      @media (max-width: 400px) {
        .hex-circuit.outer {
          width: 100px;
          height: 100px;
        }

        .hex-circuit.middle {
          width: 80px;
          height: 80px;
        }

        .hex-circuit.inner {
          width: 50px;
          height: 50px;
        }

        .hex-node {
          width: 24px;
          height: 24px;
          font-size: 10px;
        }
      }

      /* Add styles for help modal */
      .help-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 1000;
        justify-content: center;
        align-items: center;
      }

      .help-content {
        background-color: #fff;
        padding: 20px;
        border-radius: 10px;
        max-width: 600px;
        max-height: 80vh;
        overflow-y: auto;
        position: relative;
      }

      .help-content h2 {
        color: #333;
        margin-bottom: 15px;
      }

      .help-content h3 {
        color: #444;
        margin: 15px 0 10px;
      }

      .help-content p {
        margin: 10px 0;
        line-height: 1.5;
      }

      .help-content ul {
        margin: 10px 0;
        padding-left: 20px;
      }

      .help-content li {
        margin: 5px 0;
      }

      .close-help {
        position: absolute;
        top: 10px;
        right: 10px;
        font-size: 24px;
        cursor: pointer;
        color: #666;
      }

      .close-help:hover {
        color: #333;
      }

      /* Add styles for results modal */
      .results-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 1000;
        justify-content: center;
        align-items: center;
      }

      .results-content {
        background-color: #fff;
        padding: 30px;
        border-radius: 15px;
        max-width: 500px;
        width: 90%;
        text-align: center;
        position: relative;
        animation: fadeIn 0.5s ease-in;
      }

      .results-content h2 {
        color: #333;
        margin-bottom: 20px;
        font-size: 28px;
      }

      .results-content .winner {
        font-size: 24px;
        margin: 20px 0;
        padding: 15px;
        border-radius: 10px;
      }

      .results-content .winner.red {
        background-color: rgba(255, 107, 107, 0.1);
        color: var(--red-color);
      }

      .results-content .winner.blue {
        background-color: rgba(77, 150, 255, 0.1);
        color: var(--blue-color);
      }

      .results-content .scores {
        display: flex;
        justify-content: space-around;
        margin: 20px 0;
      }

      .results-content .score-box {
        padding: 15px;
        border-radius: 10px;
        width: 45%;
      }

      .results-content .score-box.red {
        background-color: rgba(255, 107, 107, 0.1);
        border: 2px solid var(--red-color);
      }

      .results-content .score-box.blue {
        background-color: rgba(77, 150, 255, 0.1);
        border: 2px solid var(--blue-color);
      }

      .results-content .score-value {
        font-size: 32px;
        font-weight: bold;
        margin: 10px 0;
      }

      .results-content .close-results {
        position: absolute;
        top: 15px;
        right: 15px;
        font-size: 24px;
        cursor: pointer;
        color: #666;
      }

      .results-content .close-results:hover {
        color: #333;
      }

      .results-content .new-game-btn {
        margin-top: 20px;
        padding: 12px 30px;
        font-size: 18px;
      }
    </style>
  </head>
  <body>
    <div class="game-info">
      <div class="player-info red active" id="player-red">
        <h2>Red Player</h2>
        <div class="timer" id="timer-red">2:00</div>
        <div class="score">Score: <span id="score-red">0</span></div>
        <div class="titan-count">Titans: <span id="titans-red">4</span>/4</div>
      </div>
      <div class="player-info blue" id="player-blue">
        <h2>Blue Player</h2>
        <div class="timer" id="timer-blue">2:00</div>
        <div class="score">Score: <span id="score-blue">0</span></div>
        <div class="titan-count">Titans: <span id="titans-blue">4</span>/4</div>
      </div>
    </div>

    <div class="game-container">
      <div class="hex-grid" id="hex-grid"></div>
    </div>

    <div class="game-status" id="game-status">
      Red player's turn - Place your titan
    </div>

    <div class="controls">
      <button id="help-btn" class="secondary">How to Play</button>
      <button id="reset-btn">Reset Game</button>
      <button id="pause-btn">Pause</button>
      <button id="undo-btn" class="secondary" disabled>Undo</button>
      <button id="redo-btn" class="secondary" disabled>Redo</button>
      <button id="sound-btn" class="secondary">Sound: ON</button>
      <button id="ai-btn" class="secondary">Play vs AI</button>
    </div>

    <div class="move-history">
      <h3 style="font-weight: bold">Move History</h3>
      <div id="history-list"></div>
    </div>

    <div class="help-modal" id="help-modal">
      <div class="help-content">
        <span class="close-help" id="close-help">&times;</span>
        <h2>How to Play Titan's Circuit</h2>
        
        <h3>Game Overview</h3>
        <p>Titan's Circuit is a strategic hexagonal board game where players compete to control circuits and score points.</p>

        <h3>Setup</h3>
        <ul>
          <li>Players take turns placing their titans (4 each) on the board</li>
          <li>Start by placing titans in the outer circuit</li>
          <li>Must fill the outer circuit completely before moving to middle circuit</li>
          <li>Must fill the middle circuit completely before moving to inner circuit</li>
        </ul>

        <h3>Gameplay</h3>
        <ul>
          <li>After placing all titans, players take turns moving their titans</li>
          <li>Each titan can move to any adjacent empty node</li>
          <li>When two of your titans are connected by an edge, you control that edge</li>
          <li>Each edge has a point value (shown on the edge)</li>
          <li>Score points by controlling edges between your titans</li>
        </ul>

        <h3>Scoring</h3>
        <ul>
          <li>Outer circuit edges: 1 point each</li>
          <li>Middle circuit edges: 6 points each</li>
          <li>Inner circuit edges: 8-9 points each</li>
          <li>Higher value edges are closer to the center</li>
        </ul>

        <h3>Winning</h3>
        <p>The player with the highest score when time runs out wins!</p>

        <h3>Controls</h3>
        <ul>
          <li>Click nodes to place or move titans</li>
          <li>Use Undo/Redo to take back or replay moves</li>
          <li>Pause button to pause the game</li>
          <li>Reset to start a new game</li>
          <li>Toggle sound effects on/off</li>
          <li>Play against AI or another player</li>
        </ul>

        <h3>Tips</h3>
        <ul>
          <li>Control high-value edges in the inner circuit for more points</li>
          <li>Block your opponent from controlling valuable edges</li>
          <li>Watch the timer - plan your moves efficiently</li>
          <li>Use the movement phase to create new connections and score points</li>
        </ul>
      </div>
    </div>

    <div class="results-modal" id="results-modal">
      <div class="results-content">
        <span class="close-results" id="close-results">&times;</span>
        <h2>Game Over</h2>
        <div id="winner-display" class="winner"></div>
        <div class="scores">
          <div class="score-box red">
            <div>Red Player</div>
            <div class="score-value" id="final-score-red">0</div>
          </div>
          <div class="score-box blue">
            <div>Blue Player</div>
            <div class="score-value" id="final-score-blue">0</div>
          </div>
        </div>
        <button class="new-game-btn" id="new-game-btn">New Game</button>
      </div>
    </div>

    <audio id="place-sound" src="arcade jump.wav" preload="auto"></audio>
    <audio id="move-sound" src="arcade move.wav" preload="auto"></audio>
    <audio id="capture-sound" src="arcade capture.wav" preload="auto"></audio>
    <audio
      id="eliminate-sound"
      src="arcade game over.wav"
      preload="auto"
    ></audio>

    <script>
      class TitanGame {
        constructor() {
          // Game constants
          this.EDGE_WEIGHTS = [
            1, 1, 1, 1, 1, 1, 1, 6, 1, 6, 1, 6, 8, 9, 8, 9, 8, 9,
          ];
          this.TOTAL_TITANS = 4;
          this.TURN_TIME = 30; // seconds per turn
          this.GAME_TIME = 120; // seconds per player

          // DOM elements
          this.hexGrid = document.getElementById("hex-grid");
          this.playerRed = document.getElementById("player-red");
          this.playerBlue = document.getElementById("player-blue");
          this.timerRed = document.getElementById("timer-red");
          this.timerBlue = document.getElementById("timer-blue");
          this.scoreRed = document.getElementById("score-red");
          this.scoreBlue = document.getElementById("score-blue");
          this.titansRed = document.getElementById("titans-red");
          this.titansBlue = document.getElementById("titans-blue");
          this.gameStatus = document.getElementById("game-status");
          this.resetBtn = document.getElementById("reset-btn");
          this.pauseBtn = document.getElementById("pause-btn");
          this.undoBtn = document.getElementById("undo-btn");
          this.redoBtn = document.getElementById("redo-btn");
          this.soundBtn = document.getElementById("sound-btn");
          this.aiBtn = document.getElementById("ai-btn");
          this.historyList = document.getElementById("history-list");
          this.helpBtn = document.getElementById('help-btn');
          this.helpModal = document.getElementById('help-modal');
          this.closeHelp = document.getElementById('close-help');
          this.resultsModal = document.getElementById('results-modal');
          this.closeResults = document.getElementById('close-results');
          this.newGameBtn = document.getElementById('new-game-btn');

          // Add start game button
          this.addStartGameButton();

          // Audio elements
          this.placeSound = document.getElementById("place-sound");
          this.moveSound = document.getElementById("move-sound");
          this.captureSound = document.getElementById("capture-sound");
          this.eliminateSound = document.getElementById("eliminate-sound");

          // Initialize game
          this.initGame();

          // Event listeners
          this.resetBtn.addEventListener("click", () => location.reload());
          this.pauseBtn.addEventListener("click", () => this.togglePause());
          this.undoBtn.addEventListener("click", () => this.undoMove());
          this.redoBtn.addEventListener("click", () => this.redoMove());
          this.soundBtn.addEventListener("click", () => this.toggleSound());
          this.aiBtn.addEventListener("click", () => this.toggleAIMode());
          this.helpBtn.addEventListener('click', () => this.showHelp());
          this.closeHelp.addEventListener('click', () => this.hideHelp());
          this.closeResults.addEventListener('click', () => this.hideResults());
          this.newGameBtn.addEventListener('click', () => location.reload());
          window.addEventListener('click', (e) => {
            if (e.target === this.helpModal) {
              this.hideHelp();
            }
          });
          
          // Add resize handler
          window.addEventListener('resize', () => {
            this.hexGrid.innerHTML = '';
            this.createHexGrid();
            this.updateUI();
          });
        }

        addStartGameButton() {
          const startBtn = document.createElement("button");
          startBtn.className = "start-btn";
          startBtn.textContent = "Start Game";
          startBtn.style.cssText = `
                  background-color: #4CAF50;
                  color: white;
                  padding: 15px 30px;
                  font-size: 18px;
                  margin: 20px 0;
              `;
          startBtn.addEventListener("click", () => this.startGame());
          document
            .querySelector(".controls")
            .insertBefore(
              startBtn,
              document.querySelector(".controls").firstChild
            );
        }

        initGame() {
          // Game state
          this.state = {
            currentPlayer: "red",
            phase: "placement",
            placedTitans: { red: 0, blue: 0 },
            scores: { red: 0, blue: 0 },
            timeLeft: { red: this.GAME_TIME, blue: this.GAME_TIME },
            turnTimeLeft: this.TURN_TIME,
            nodes: [],
            edges: [],
            controlledEdges: { red: [], blue: [] },
            gameActive: false,
            gamePaused: false,
            soundEnabled: true,
            aiMode: false,
            aiPlayer: "blue",
            moveHistory: [],
            historyIndex: -1,
            selectedNode: null,
            highlightedNodes: [],
            doublePoints: false,
          };

          // Clear the grid and history
          this.hexGrid.innerHTML = "";
          this.historyList.innerHTML = "";

          // Create the hexagonal grid
          this.createHexGrid();

          // Update UI
          this.updateUI();

          // Update status
          this.updateStatus('Click "Start Game" to begin');

          // Disable game controls
          this.pauseBtn.disabled = true;
          this.undoBtn.disabled = true;
          this.redoBtn.disabled = true;
        }

        startGame() {
          this.state.gameActive = true;
          this.pauseBtn.disabled = false;
          this.undoBtn.disabled = false;
          this.redoBtn.disabled = false;

          // Set initial player active state
          this.playerRed.classList.add("active");
          this.playerBlue.classList.remove("active");

          this.updateStatus(
            `${this.capitalize(
              this.state.currentPlayer
            )} player's turn - Place your titan`
          );
          this.startTimers();

          // If AI mode is on and AI is first player, make AI move
          if (
            this.state.aiMode &&
            this.state.currentPlayer === this.state.aiPlayer
          ) {
            setTimeout(() => this.makeAIMove(), 1000);
          }
        }

        createHexGrid() {
          const viewportWidth = window.innerWidth;
          const baseRadius = Math.min(viewportWidth * 0.4, 200);
          
          const outerRadius = baseRadius;
          const middleRadius = baseRadius * 0.7;
          const innerRadius = baseRadius * 0.4;
          
          const centerX = this.hexGrid.offsetWidth / 2;
          const centerY = this.hexGrid.offsetHeight / 2;

          // Create nodes for each circuit
          const outerNodes = this.createHexagonNodes(
            outerRadius,
            centerX,
            centerY,
            "outer"
          );
          const middleNodes = this.createHexagonNodes(
            middleRadius,
            centerX,
            centerY,
            "middle"
          );
          const innerNodes = this.createHexagonNodes(
            innerRadius,
            centerX,
            centerY,
            "inner"
          );

          // Combine all nodes
          this.state.nodes = [...outerNodes, ...middleNodes, ...innerNodes];

          // Create edges between nodes
          this.createEdges();
        }

        createHexagonNodes(radius, centerX, centerY, circuit) {
          const nodes = [];
          const angleStep = Math.PI / 3; // 60 degrees

          // Create 6 nodes for the hexagon
          for (let i = 0; i < 6; i++) {
            const angle = i * angleStep;
            const x = centerX + radius * Math.cos(angle);
            const y = centerY + radius * Math.sin(angle);

            const node = {
              id: `${circuit}-${i}`,
              x,
              y,
              circuit,
              occupied: null,
              element: null,
            };

            nodes.push(node);

            // Create DOM element for the node
            const nodeElement = document.createElement("div");
            nodeElement.className = "hex-node";
            nodeElement.style.left = `${x}px`;
            nodeElement.style.top = `${y}px`;
            nodeElement.dataset.id = node.id;

            nodeElement.addEventListener("click", () =>
              this.handleNodeClick(node)
            );

            this.hexGrid.appendChild(nodeElement);
            node.element = nodeElement;
          }

          return nodes;
        }

        createEdges() {
          let edgeIndex = 0;

          // Only connect nodes within each circuit (hexagon sides)
          this.connectCircuitNodes("outer", edgeIndex);
          edgeIndex += 6;
          this.connectCircuitNodes("middle", edgeIndex);
          edgeIndex += 6;
          this.connectCircuitNodes("inner", edgeIndex);
          edgeIndex += 6;

          // Only connect corresponding nodes between circuits (radials)
          for (let i = 0; i < 6; i++) {
            // Outer to middle
            this.createEdgeBetweenNodes(
              this.getNodeById(`outer-${i}`),
              this.getNodeById(`middle-${i}`),
              edgeIndex++
            );
            // Middle to inner
            this.createEdgeBetweenNodes(
              this.getNodeById(`middle-${i}`),
              this.getNodeById(`inner-${i}`),
              edgeIndex++
            );
          }
        }

        connectCircuitNodes(circuit, startEdgeIndex) {
          for (let i = 0; i < 6; i++) {
            const node1 = this.getNodeById(`${circuit}-${i}`);
            const node2 = this.getNodeById(`${circuit}-${(i + 1) % 6}`);
            this.createEdgeBetweenNodes(node1, node2, startEdgeIndex + i);
          }
        }

        createEdgeBetweenNodes(node1, node2, edgeIndex) {
          const dx = node2.x - node1.x;
          const dy = node2.y - node1.y;
          const length = Math.sqrt(dx * dx + dy * dy);
          const angle = (Math.atan2(dy, dx) * 180) / Math.PI;

          const edge = {
            id: `edge-${edgeIndex}`,
            node1: node1.id,
            node2: node2.id,
            weight: this.EDGE_WEIGHTS[edgeIndex],
            controlledBy: null,
            element: null,
          };

          this.state.edges.push(edge);

          // Create DOM element for the edge
          const edgeElement = document.createElement("div");
          edgeElement.className = "hex-edge";
          edgeElement.style.width = `${length}px`;
          edgeElement.style.left = `${node1.x}px`;
          edgeElement.style.top = `${node1.y}px`;
          edgeElement.style.transform = `rotate(${angle}deg)`;
          edgeElement.dataset.id = edge.id;

          // Add weight label
          const weightElement = document.createElement("div");
          weightElement.className = "edge-weight";
          weightElement.textContent = edge.weight;
          const midX = node1.x + dx / 2;
          const midY = node1.y + dy / 2;
          // Move label 20% closer to center
          const centerX = this.hexGrid.offsetWidth / 2;
          const centerY = this.hexGrid.offsetHeight / 2;
          const labelX = midX + (centerX - midX) * 0.2;
          const labelY = midY + (centerY - midY) * 0.2;
          weightElement.style.left = `${labelX}px`;
          weightElement.style.top = `${labelY}px`;

          this.hexGrid.appendChild(edgeElement);
          this.hexGrid.appendChild(weightElement);
          edge.element = edgeElement;
        }

        handleNodeClick(node) {
          if (!this.state.gameActive || this.state.gamePaused) return;

          // AI move if it's AI's turn
          if (
            this.state.aiMode &&
            this.state.currentPlayer === this.state.aiPlayer
          ) {
            return;
          }

          if (this.state.phase === "placement") {
            this.handlePlacement(node);
          } else if (this.state.phase === "movement") {
            this.handleMovement(node);
          }
        }

        handlePlacement(node) {
          // Check if node is available for placement
          if (node.occupied !== null) return;

          // Check if placement is allowed in current circuit
          const allowedCircuit = this.getCurrentCircuit();
          if (node.circuit !== allowedCircuit) return;

          // Place the titan
          node.occupied = this.state.currentPlayer;
          node.element.classList.add(this.state.currentPlayer);

          // Update placed titans count
          this.state.placedTitans[this.state.currentPlayer]++;

          // Check if all titans are placed
          if (
            this.state.placedTitans[this.state.currentPlayer] ===
            this.TOTAL_TITANS
          ) {
            // Switch to movement phase if both players have placed all titans
            if (
              this.state.placedTitans.red === this.TOTAL_TITANS &&
              this.state.placedTitans.blue === this.TOTAL_TITANS
            ) {
              this.state.phase = "movement";
              this.updateStatus(
                `${this.capitalize(
                  this.state.currentPlayer
                )} player's turn - Move your titan`
              );
            }
          }

          // Save state for undo/redo
          this.saveState();

          // Add to history
          this.addToHistory(`placed titan at ${node.id}`);

          // Switch player
          this.switchPlayer();

          // Play sound
          this.playSound(this.placeSound);

          // Update UI
          this.updateUI();

          // Make AI move if in AI mode
          if (
            this.state.aiMode &&
            this.state.currentPlayer === this.state.aiPlayer
          ) {
            setTimeout(() => this.makeAIMove(), 1000);
          }
        }

        handleMovement(node) {
          // If no node is selected, select this node if it belongs to current player
          if (!this.state.selectedNode) {
            if (node.occupied === this.state.currentPlayer) {
              this.state.selectedNode = node;
              node.element.classList.add("selected");

              // Highlight valid moves
              const validMoves = this.getValidMoves(node);
              validMoves.forEach((move) => {
                move.element.classList.add("highlight");
                this.state.highlightedNodes.push(move);
              });

              this.updateStatus(
                `${this.capitalize(
                  this.state.currentPlayer
                )} player - Select destination`
              );
              return;
            }
            return;
          }

          // If a node is already selected, try to move to the clicked node
          if (this.state.selectedNode === node) {
            // Deselect the node
            this.state.selectedNode.element.classList.remove("selected");
            this.state.selectedNode = null;

            // Remove highlights
            this.state.highlightedNodes.forEach((node) => {
              node.element.classList.remove("highlight");
            });
            this.state.highlightedNodes = [];

            this.updateStatus(
              `${this.capitalize(
                this.state.currentPlayer
              )} player's turn - Move your titan`
            );
            return;
          }

          // Check if the move is valid
          const validMoves = this.getValidMoves(this.state.selectedNode);
          if (!validMoves.includes(node)) {
            return;
          }

          // Move the titan
          const oldNode = this.state.selectedNode;
          oldNode.occupied = null;
          oldNode.element.classList.remove(
            this.state.currentPlayer,
            "selected"
          );

          node.occupied = this.state.currentPlayer;
          node.element.classList.add(this.state.currentPlayer);

          // Remove highlights
          this.state.highlightedNodes.forEach((node) => {
            node.element.classList.remove("highlight");
          });
          this.state.highlightedNodes = [];
          this.state.selectedNode = null;

          // Check for edge control
          this.updateEdgeControl();

          // Check for titan elimination
          this.checkTitanElimination();

          // Save state for undo/redo
          this.saveState();

          // Add to history
          this.addToHistory(`moved titan from ${oldNode.id} to ${node.id}`);

          // Switch player
          this.switchPlayer();

          // Play sound
          this.playSound(this.moveSound);

          // Update UI
          this.updateUI();

          // Make AI move if in AI mode
          if (
            this.state.aiMode &&
            this.state.currentPlayer === this.state.aiPlayer
          ) {
            setTimeout(() => this.makeAIMove(), 1000);
          }
        }

        getCurrentCircuit() {
          // Count occupied nodes in each circuit
          const outerCount = this.state.nodes.filter(
            (n) => n.circuit === "outer" && n.occupied !== null
          ).length;
          const middleCount = this.state.nodes.filter(
            (n) => n.circuit === "middle" && n.occupied !== null
          ).length;

          // Must fill outer circuit completely (6 nodes) before moving to middle
          if (outerCount < 6) return "outer";
          
          // Must fill middle circuit completely (6 nodes) before moving to inner
          if (middleCount < 6) return "middle";
          
          return "inner";
        }

        getValidMoves(node) {
          const validMoves = [];

          // Get all edges connected to this node
          const connectedEdges = this.state.edges.filter(
            (edge) => edge.node1 === node.id || edge.node2 === node.id
          );

          // Check each connected node
          connectedEdges.forEach((edge) => {
            const connectedNodeId =
              edge.node1 === node.id ? edge.node2 : edge.node1;
            const connectedNode = this.getNodeById(connectedNodeId);

            // Node is valid if it's empty
            if (connectedNode.occupied === null) {
              validMoves.push(connectedNode);
            }
          });

          return validMoves;
        }

        updateEdgeControl() {
          // Reset all edge control and scores
          this.state.edges.forEach((edge) => {
            edge.controlledBy = null;
            edge.element.className = "hex-edge";
          });

          // Reset scores before recalculating
          this.state.scores = { red: 0, blue: 0 };

          // Check each edge for control
          this.state.edges.forEach((edge) => {
            const node1 = this.getNodeById(edge.node1);
            const node2 = this.getNodeById(edge.node2);

            if (
              node1.occupied &&
              node2.occupied &&
              node1.occupied === node2.occupied
            ) {
              edge.controlledBy = node1.occupied;
              edge.element.classList.add("controlled-edge", node1.occupied);

              // Update score
              this.state.scores[node1.occupied] += edge.weight;
            }
          });

          // Update score display
          this.scoreRed.textContent = this.state.scores.red;
          this.scoreBlue.textContent = this.state.scores.blue;

          // Check for win condition (25 points)
          if (this.state.scores.red >= 25 || this.state.scores.blue >= 25) {
            const winner = this.state.scores.red >= 25 ? 'red' : 'blue';
            this.endGame(winner);
          }
        }

        checkTitanElimination() {
          this.state.nodes.forEach((node) => {
            if (node.occupied === null) return;

            const adjacentNodes = this.getAdjacentNodes(node);
            const allAdjacentOccupied = adjacentNodes.every(
              (adjNode) => adjNode.occupied !== null
            );
            const allAdjacentOpponent = adjacentNodes.every(
              (adjNode) =>
                adjNode.occupied === this.getOpponentColor(node.occupied)
            );

            if (allAdjacentOccupied && allAdjacentOpponent) {
              // Eliminate the titan
              node.occupied = null;
              node.element.className = "hex-node";

              // Update placed titans count
              this.state.placedTitans[this.state.currentPlayer]--;

              // Play elimination sound
              this.playSound(this.eliminateSound);

              // Add to history
              this.addToHistory(
                `eliminated ${this.state.currentPlayer} titan at ${node.id}`
              );
            }
          });
        }

        getAdjacentNodes(node) {
          const adjacentNodes = [];

          this.state.edges.forEach((edge) => {
            if (edge.node1 === node.id) {
              adjacentNodes.push(this.getNodeById(edge.node2));
            } else if (edge.node2 === node.id) {
              adjacentNodes.push(this.getNodeById(edge.node1));
            }
          });

          return adjacentNodes;
        }

        getOpponentColor(color) {
          return color === "red" ? "blue" : "red";
        }

        toggleSound() {
          this.state.soundEnabled = !this.state.soundEnabled;
          this.soundBtn.textContent = `Sound: ${
            this.state.soundEnabled ? "ON" : "OFF"
          }`;
        }

        toggleAIMode() {
          this.state.aiMode = !this.state.aiMode;
          this.aiBtn.textContent = this.state.aiMode
            ? "Play vs Human"
            : "Play vs AI";
          this.aiBtn.classList.toggle("secondary", !this.state.aiMode);
          this.aiBtn.classList.toggle("danger", this.state.aiMode);

          // If game is active and it's AI's turn, make AI move
          if (
            this.state.gameActive &&
            this.state.aiMode &&
            this.state.currentPlayer === this.state.aiPlayer
          ) {
            setTimeout(() => this.makeAIMove(), 1000);
          }
        }

        playSound(soundElement) {
          if (this.state.soundEnabled) {
            soundElement.currentTime = 0;
            soundElement
              .play()
              .catch((e) => console.log("Audio play failed:", e));
          }
        }

        saveState() {
          // Clear any redo history
          this.state.moveHistory = this.state.moveHistory.slice(
            0,
            this.state.historyIndex + 1
          );

          // Create a deep copy of the current state without circular references
          const stateCopy = {
            currentPlayer: this.state.currentPlayer,
            phase: this.state.phase,
            placedTitans: { ...this.state.placedTitans },
            scores: { ...this.state.scores },
            timeLeft: { ...this.state.timeLeft },
            turnTimeLeft: this.state.turnTimeLeft,
            gameActive: this.state.gameActive,
            gamePaused: this.state.gamePaused,
            soundEnabled: this.state.soundEnabled,
            aiMode: this.state.aiMode,
            aiPlayer: this.state.aiPlayer,
            moveHistory: [...this.state.moveHistory],
            historyIndex: this.state.historyIndex,
            nodes: this.state.nodes.map(node => ({
              id: node.id,
              x: node.x,
              y: node.y,
              circuit: node.circuit,
              occupied: node.occupied
            })),
            edges: this.state.edges.map(edge => ({
              id: edge.id,
              node1: edge.node1,
              node2: edge.node2,
              weight: edge.weight,
              controlledBy: edge.controlledBy
            })),
            controlledEdges: {
              red: [...this.state.controlledEdges.red],
              blue: [...this.state.controlledEdges.blue]
            }
          };

          // Add to history
          this.state.moveHistory.push(stateCopy);
          this.state.historyIndex = this.state.moveHistory.length - 1;
        }

        undoMove() {
          if (this.state.historyIndex < 0) return;

          this.state.historyIndex--;
          this.restoreState();

          // Add to history
          this.addToHistory(
            `${this.capitalize(this.state.currentPlayer)} undid last move`
          );
        }

        redoMove() {
          if (this.state.historyIndex >= this.state.moveHistory.length - 1)
            return;

          this.state.historyIndex++;
          this.restoreState();

          // Add to history
          this.addToHistory(
            `${this.capitalize(this.state.currentPlayer)} redid move`
          );
        }

        restoreState() {
          if (this.state.historyIndex < 0) {
            this.initGame();
            return;
          }

          const savedState = this.state.moveHistory[this.state.historyIndex];

          // Restore basic state
          this.state.currentPlayer = savedState.currentPlayer;
          this.state.phase = savedState.phase;
          this.state.placedTitans = { ...savedState.placedTitans };
          this.state.scores = { ...savedState.scores };
          this.state.timeLeft = { ...savedState.timeLeft };
          this.state.turnTimeLeft = savedState.turnTimeLeft;
          this.state.controlledEdges = {
            red: [...savedState.controlledEdges.red],
            blue: [...savedState.controlledEdges.blue],
          };
          this.state.gameActive = savedState.gameActive;
          this.state.gamePaused = savedState.gamePaused;
          this.state.selectedNode = null;
          this.state.highlightedNodes = [];

          // Restore nodes
          this.state.nodes.forEach((node) => {
            const savedNode = savedState.nodes.find((n) => n.id === node.id);
            if (savedNode) {
              node.occupied = savedNode.occupied;
              node.element.className = "hex-node";
              if (node.occupied) {
                node.element.classList.add(node.occupied);
              }
            }
          });

          // Restore edges
          this.state.edges.forEach((edge) => {
            const savedEdge = savedState.edges.find((e) => e.id === edge.id);
            if (savedEdge) {
              edge.controlledBy = savedEdge.controlledBy;
              edge.element.className = "hex-edge";
              if (edge.controlledBy) {
                edge.element.classList.add(
                  "controlled-edge",
                  edge.controlledBy
                );
              }
            }
          });

          // Update UI
          this.updateUI();
          this.updateTimerDisplay();

          // Update player active state
          this.playerRed.classList.toggle(
            "active",
            this.state.currentPlayer === "red"
          );
          this.playerBlue.classList.toggle(
            "active",
            this.state.currentPlayer === "blue"
          );

          // Update status message
          if (this.state.phase === "placement") {
            this.updateStatus(
              `${this.capitalize(
                this.state.currentPlayer
              )} player's turn - Place your titan`
            );
          } else {
            this.updateStatus(
              `${this.capitalize(
                this.state.currentPlayer
              )} player's turn - Move your titan`
            );
          }
        }

        addToHistory(message) {
          const moveItem = document.createElement("div");
          moveItem.className = "move-item";

          const movePlayer = document.createElement("span");
          movePlayer.className = `move-player ${this.state.currentPlayer}`;
          movePlayer.textContent = `${this.capitalize(
            this.state.currentPlayer
          )}: `;

          const moveText = document.createElement("span");
          moveText.textContent = message;

          moveItem.appendChild(movePlayer);
          moveItem.appendChild(moveText);
          this.historyList.appendChild(moveItem);

          // Scroll to bottom
          this.historyList.scrollTop = this.historyList.scrollHeight;
        }

        getNodeById(id) {
          return this.state.nodes.find((node) => node.id === id);
        }

        makeAIMove() {
          if (
            !this.state.gameActive ||
            this.state.gamePaused ||
            !this.state.aiMode ||
            this.state.currentPlayer !== this.state.aiPlayer
          ) {
            return;
          }

          // Add a small delay to make AI moves feel more natural
          setTimeout(() => {
            if (this.state.phase === "placement") {
              this.makeAIPlacement();
            } else {
              this.makeAIMovement();
            }
          }, 1000);
        }

        makeAIPlacement() {
          // Get the current allowed circuit
          const allowedCircuit = this.getCurrentCircuit();
          
          // Find all valid placement nodes in the allowed circuit
          const validNodes = this.state.nodes.filter(
            (node) => node.occupied === null && node.circuit === allowedCircuit
          );

          if (validNodes.length === 0) return;

          // AI strategy for placement:
          // 1. Try to place near existing titans to control edges
          // 2. If no good placement found, place randomly
          let bestNode = null;
          let maxScore = -1;

          for (const node of validNodes) {
            // Simulate placing a titan here
            node.occupied = this.state.aiPlayer;
            
            // Calculate potential score from this placement
            let potentialScore = 0;
            const adjacentNodes = this.getAdjacentNodes(node);
            
            for (const adjNode of adjacentNodes) {
              if (adjNode.occupied === this.state.aiPlayer) {
                // Find the edge between these nodes
                const edge = this.state.edges.find(
                  (e) =>
                    (e.node1 === node.id && e.node2 === adjNode.id) ||
                    (e.node1 === adjNode.id && e.node2 === node.id)
                );
                if (edge) {
                  potentialScore += edge.weight;
                }
              }
            }

            // Undo the simulation
            node.occupied = null;

            // Update best node if this placement is better
            if (potentialScore > maxScore) {
              maxScore = potentialScore;
              bestNode = node;
            }
          }

          // If no strategic placement found, choose randomly
          if (!bestNode) {
            const randomIndex = Math.floor(Math.random() * validNodes.length);
            bestNode = validNodes[randomIndex];
          }

          // Make the move
          this.handlePlacement(bestNode);
        }

        makeAIMovement() {
          // Get all AI's titans
          const aiTitans = this.state.nodes.filter(
            (node) => node.occupied === this.state.aiPlayer
          );

          if (aiTitans.length === 0) return;

          let bestMove = null;
          let bestScore = -1;
          let bestSource = null;

          // Try each titan
          for (const titan of aiTitans) {
            const validMoves = this.getValidMoves(titan);
            
            // Try each possible move
            for (const target of validMoves) {
              // Simulate the move
              titan.occupied = null;
              target.occupied = this.state.aiPlayer;

              // Calculate potential score from this move
              let potentialScore = 0;
              
              // Check for new edge controls
              this.state.edges.forEach((edge) => {
                const node1 = this.getNodeById(edge.node1);
                const node2 = this.getNodeById(edge.node2);
                
                if (
                  node1.occupied === this.state.aiPlayer &&
                  node2.occupied === this.state.aiPlayer
                ) {
                  potentialScore += edge.weight;
                }
              });

              // Check for opponent titan elimination
              const adjacentNodes = this.getAdjacentNodes(target);
              const opponentColor = this.getOpponentColor(this.state.aiPlayer);
              
              for (const adjNode of adjacentNodes) {
                if (
                  adjNode.occupied === opponentColor &&
                  this.getAdjacentNodes(adjNode).every(
                    (n) => n.occupied === this.state.aiPlayer
                  )
                ) {
                  potentialScore += 10; // Bonus for elimination
                }
              }

              // Undo the simulation
              titan.occupied = this.state.aiPlayer;
              target.occupied = null;

              // Update best move if this is better
              if (potentialScore > bestScore) {
                bestScore = potentialScore;
                bestMove = target;
                bestSource = titan;
              }
            }
          }

          // If no strategic move found, make a random move
          if (!bestMove) {
            const randomTitan = aiTitans[Math.floor(Math.random() * aiTitans.length)];
            const validMoves = this.getValidMoves(randomTitan);
            if (validMoves.length > 0) {
              bestMove = validMoves[Math.floor(Math.random() * validMoves.length)];
              bestSource = randomTitan;
            }
          }

          // Make the move if we found one
          if (bestMove && bestSource) {
            // First select the source titan
            this.handleMovement(bestSource);
            // Then move to the target
            setTimeout(() => {
              this.handleMovement(bestMove);
            }, 500);
          }
        }

        switchPlayer() {
          this.state.currentPlayer =
            this.state.currentPlayer === "red" ? "blue" : "red";

          // Update player info active state
          this.playerRed.classList.toggle(
            "active",
            this.state.currentPlayer === "red"
          );
          this.playerBlue.classList.toggle(
            "active",
            this.state.currentPlayer === "blue"
          );

          // Update status message
          if (this.state.phase === "placement") {
            this.updateStatus(
              `${this.capitalize(
                this.state.currentPlayer
              )} player's turn - Place your titan`
            );
          } else {
            this.updateStatus(
              `${this.capitalize(
                this.state.currentPlayer
              )} player's turn - Move your titan`
            );
          }

          // Reset turn timer
          this.state.turnTimeLeft = this.TURN_TIME;
          this.updateTimerDisplay();
        }

        updateTimerDisplay() {
          // Update current player's timer
          const timeLeft = this.state.timeLeft[this.state.currentPlayer];
          const minutes = Math.floor(timeLeft / 60);
          const seconds = timeLeft % 60;
          
          // Update both timers
          this.timerRed.textContent = this.state.currentPlayer === 'red' 
            ? `${minutes}:${seconds.toString().padStart(2, "0")}`
            : "0:00";
            
          this.timerBlue.textContent = this.state.currentPlayer === 'blue'
            ? `${minutes}:${seconds.toString().padStart(2, "0")}`
            : "0:00";
        }

        updateStatus(message) {
          const statusElement = document.getElementById("game-status");
          statusElement.textContent = message;

          // Update status color based on current player
          statusElement.className = "game-status";
          if (this.state.gameActive) {
            statusElement.classList.add(this.state.currentPlayer);
          }
        }

        updateUI() {
          this.state.nodes.forEach((node) => {
            node.element.className = "hex-node";
            if (node.occupied) {
              node.element.classList.add(node.occupied);
            }
          });

          this.state.edges.forEach((edge) => {
            edge.element.className = "hex-edge";
            if (edge.controlledBy) {
              edge.element.classList.add("controlled-edge", edge.controlledBy);
            }
          });
        }

        startTimers() {
          // Clear any existing timers
          if (this.gameTimer) clearInterval(this.gameTimer);
          if (this.turnTimer) clearInterval(this.turnTimer);

          // Start the game timer
          this.gameTimer = setInterval(() => {
            if (!this.state.gameActive || this.state.gamePaused) return;

            this.state.timeLeft[this.state.currentPlayer]--;
            this.updateTimerDisplay();

            // Check if time is up
            if (this.state.timeLeft[this.state.currentPlayer] <= 0) {
              this.endGame();
            }
          }, 1000);

          // Start the turn timer
          this.turnTimer = setInterval(() => {
            if (!this.state.gameActive || this.state.gamePaused) return;

            this.state.turnTimeLeft--;
            this.updateTurnTimerDisplay();

            // Check if turn time is up
            if (this.state.turnTimeLeft <= 0) {
              this.switchPlayer();
              this.state.turnTimeLeft = this.TURN_TIME;
            }
          }, 1000);
        }

        updateTurnTimerDisplay() {
          const minutes = Math.floor(this.state.turnTimeLeft / 60);
          const seconds = this.state.turnTimeLeft % 60;
          const timerElement =
            this.state.currentPlayer === "red" ? this.timerRed : this.timerBlue;
          timerElement.textContent = `${minutes}:${seconds
            .toString()
            .padStart(2, "0")}`;
        }

        togglePause() {
          this.state.gamePaused = !this.state.gamePaused;
          this.pauseBtn.textContent = this.state.gamePaused
            ? "Resume"
            : "Pause";

          if (this.state.gamePaused) {
            this.updateStatus("Game Paused");
          } else {
            if (this.state.phase === "placement") {
              this.updateStatus(
                `${this.capitalize(
                  this.state.currentPlayer
                )} player's turn - Place your titan`
              );
            } else {
              this.updateStatus(
                `${this.capitalize(
                  this.state.currentPlayer
                )} player's turn - Move your titan`
              );
            }
          }
        }

        endGame(winner = null) {
          this.state.gameActive = false;
          clearInterval(this.gameTimer);
          clearInterval(this.turnTimer);
          clearInterval(this.overallTimer);

          // Remove active state from both players
          this.playerRed.classList.remove("active");
          this.playerBlue.classList.remove("active");

          // Determine winner if not provided
          if (!winner) {
            if (this.state.scores.blue > this.state.scores.red) {
              winner = "blue";
            } else if (this.state.scores.blue === this.state.scores.red) {
              winner = "tie";
            } else {
              winner = "red";
            }
          }

          // Update status with winner color
          if (winner === "tie") {
            this.updateStatus("Game Over - It's a tie!");
          } else {
            this.updateStatus(`Game Over - ${this.capitalize(winner)} player wins!`);
          }

          // Update leaderboard
          this.updateLeaderboard(winner);

          // Show results modal
          this.showResults(winner);

          // Disable controls
          this.resetBtn.disabled = false;
          this.pauseBtn.disabled = true;
          this.undoBtn.disabled = true;
          this.redoBtn.disabled = true;
        }

        showResults(winner) {
          const winnerDisplay = document.getElementById('winner-display');
          const finalScoreRed = document.getElementById('final-score-red');
          const finalScoreBlue = document.getElementById('final-score-blue');

          // Update scores
          finalScoreRed.textContent = this.state.scores.red;
          finalScoreBlue.textContent = this.state.scores.blue;

          // Update winner display
          if (winner === 'tie') {
            winnerDisplay.textContent = "It's a Tie!";
            winnerDisplay.className = 'winner';
          } else {
            winnerDisplay.textContent = `${this.capitalize(winner)} Player Wins!`;
            winnerDisplay.className = `winner ${winner}`;
          }

          // Show modal
          this.resultsModal.style.display = 'flex';
        }

        hideResults() {
          this.resultsModal.style.display = 'none';
        }

        updateLeaderboard(winner) {
          // Get existing leaderboard
          let leaderboard = JSON.parse(
            localStorage.getItem("titansCircuitLeaderboard") || "[]"
          );

          // Add new game result
          leaderboard.push({
            date: new Date().toISOString(),
            winner: winner,
            redScore: this.state.scores.red,
            blueScore: this.state.scores.blue,
            duration:
              this.GAME_TIME * 2 -
              (this.state.timeLeft.red + this.state.timeLeft.blue),
          });

          // Sort by date (most recent first)
          leaderboard.sort((a, b) => new Date(b.date) - new Date(a.date));

          // Keep only last 10 games
          leaderboard = leaderboard.slice(0, 10);

          // Save to localStorage
          localStorage.setItem(
            "titansCircuitLeaderboard",
            JSON.stringify(leaderboard)
          );
        }

        capitalize(str) {
          return str.charAt(0).toUpperCase() + str.slice(1);
        }

        showHelp() {
          this.helpModal.style.display = 'flex';
        }

        hideHelp() {
          this.helpModal.style.display = 'none';
        }
      }

      // Initialize the game when the page loads
      document.addEventListener("DOMContentLoaded", () => {
        const game = new TitanGame();
      });
    </script>
  </body>
</html>
