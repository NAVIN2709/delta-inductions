<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Titan's Circuit - Hexagonal Strategy Game</title>
    <style>
      :root {
        --red-color: #ff6b6b;
        --blue-color: #4d96ff;
        --gold-color: gold;
        --dark-color: #333;
        --light-color: #f0f0f0;
        --white: #fff;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: #292d35;
        color: var(--dark-color);
        min-height: 100vh;
        padding: 20px;
      }

      h1 {
        margin: 20px 0;
        color: var(--dark-color);
        text-align: center;
      }

      .game-container {
        position: relative;
        height: min-content;
        width:min-content;
        margin: 0 auto;
      }

      .hex-grid {
        position: relative;
        width: 100%;
        height: 300px;
        margin-top: 30px;
        margin-bottom: 30px;
      }

      .hex-circuit {
        position: relative;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        opacity: 0.9;
      }

      .hex-circuit.outer {
        width: 400px;
        height: 400px;
      }

      .hex-circuit.middle {
        width: 260px;
        height: 260px;
      }

      .hex-circuit.inner {
        width: 120px;
        height: 120px;
      }

      .hex-node {
        position: absolute;
        width: 32px;
        height: 32px;
        border-radius: 50%;
        background-color: #454544;
        border: 3px solid #fdfdfc;
        transform: translate(-50%, -50%);
        cursor: pointer;
        z-index: 10;
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        transition: all 0.3s ease;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }

      .hex-node.red {
        background-color: var(--red-color);
        color: var(--white);
      }

      .hex-node.blue {
        background-color: var(--blue-color);
        color: var(--white);
      }

      .hex-node.highlight {
        box-shadow: 0 0 0 4px rgba(255, 215, 0, 0.7);
      }

      .hex-node.selected {
        box-shadow: 0 0 0 6px rgba(255, 255, 255, 0.9);
        transform: translate(-50%, -50%) scale(1.1);
      }

      .hex-edge {
        position: absolute;
        background-color: #fdfdfc;
        transform-origin: 0 0;
        z-index: 1;
        height: 3px;
        transition: all 0.3s ease;
      }

      .edge-weight {
        position: absolute;
        font-size: 15px;
        color:#fdfdfc;
        font-weight: bold;
        transform: translate(-50%, -50%);
        padding: 2px 5px;
        border-radius: 10px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        z-index: 2;
      }

      .controlled-edge.red {
        background-color: var(--red-color);
        height: 5px;
        z-index: 2;
      }

      .controlled-edge.blue {
        background-color: var(--blue-color);
        height: 5px;
        z-index: 2;
      }

      .game-info {
        display: flex;
        justify-content: space-between;
        width: 100%;
        max-width: 650px;
        margin-bottom: 20px;
        background-color: var(--white);
        padding: 15px;
        border-radius: 10px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      }

      .player-info {
        padding: 15px;
        border-radius: 8px;
        text-align: center;
        width: 48%;
        transition: all 0.3s ease;
      }

      .player-info.active {
        transform: translateY(-5px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      }

      .player-info.red {
        background-color: rgba(255, 107, 107, 0.1);
        border: 2px solid var(--red-color);
      }

      .player-info.blue {
        background-color: rgba(77, 150, 255, 0.1);
        border: 2px solid var(--blue-color);
      }

      .player-info h2 {
        margin-bottom: 10px;
        color: var(--dark-color);
      }

      .timer {
        font-size: 24px;
        font-weight: bold;
        margin: 10px 0;
        font-family: "Courier New", monospace;
      }

      .score {
        font-size: 20px;
        margin: 5px 0;
      }

      .titan-count {
        font-size: 16px;
        margin: 5px 0;
      }

      .game-status {
        width: 100%;
        max-width: 650px;
        margin: 15px 0;
        font-size: 18px;
        font-weight: bold;
        padding: 15px;
        background-color: var(--white);
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        text-align: center;
        min-height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .controls {
        display: flex;
        gap: 10px;
        width: 100%;
        max-width: 650px;
        margin-top: 10px;
        flex-wrap: wrap;
        justify-content: center;
      }

      button {
        padding: 12px 24px;
        background-color: #4caf50;
        color: var(--white);
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
        transition: all 0.3s ease;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      button:hover {
        background-color: #45a049;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      button:active {
        transform: translateY(0);
      }

      button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      button.secondary {
        background-color: #f39c12;
      }

      button.secondary:hover {
        background-color: #e67e22;
      }

      button.danger {
        background-color: #e74c3c;
      }

      button.danger:hover {
        background-color: #c0392b;
      }

      .move-history {
        width: 100%;
        max-width: 650px;
        margin-top: 20px;
        background-color: var(--white);
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        max-height: 200px;
        overflow-y: auto;
      }

      .move-history h3 {
        margin-bottom: 10px;
        text-align: center;
      }

      .move-item {
        padding: 8px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
      }

      .move-item:last-child {
        border-bottom: none;
      }

      .move-player {
        font-weight: bold;
      }

      .move-player.red {
        color: var(--red-color);
      }

      .move-player.blue {
        color: var(--blue-color);
      }

      /* Animations */
      @keyframes pulse {
        0% {
          transform: translate(-50%, -50%) scale(1);
        }
        50% {
          transform: translate(-50%, -50%) scale(1.1);
        }
        100% {
          transform: translate(-50%, -50%) scale(1);
        }
      }

      .pulse {
        animation: pulse 1.5s infinite;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .fade-in {
        animation: fadeIn 0.5s ease-in;
      }

      /* Mobile responsiveness */
      @media (max-width: 700px) {
        .hex-circuit.outer {
          width: 300px;
          height: 300px;
        }

        .hex-circuit.middle {
          width: 200px;
          height: 200px;
        }

        .hex-circuit.inner {
          width: 100px;
          height: 100px;
        }

        .hex-node {
          width: 28px;
          height: 28px;
          font-size: 12px;
        }

        .game-info {
          flex-direction: column;
          gap: 10px;
        }

        .player-info {
          width: 100%;
        }

        .controls button {
          padding: 10px 15px;
          font-size: 14px;
        }
      }

      @media (max-width: 400px) {
        .hex-circuit.outer {
          width: 250px;
          height: 250px;
        }

        .hex-circuit.middle {
          width: 160px;
          height: 160px;
        }

        .hex-circuit.inner {
          width: 80px;
          height: 80px;
        }

        .hex-node {
          width: 24px;
          height: 24px;
          font-size: 10px;
        }
      }
    </style>
  </head>
  <body>
    <div class="game-info">
      <div class="player-info red active" id="player-red">
        <h2>Red Player</h2>
        <div class="timer" id="timer-red">2:00</div>
        <div class="score">Score: <span id="score-red">0</span></div>
        <div class="titan-count">Titans: <span id="titans-red">4</span>/4</div>
      </div>
      <div class="player-info blue" id="player-blue">
        <h2>Blue Player</h2>
        <div class="timer" id="timer-blue">2:00</div>
        <div class="score">Score: <span id="score-blue">0</span></div>
        <div class="titan-count">Titans: <span id="titans-blue">4</span>/4</div>
      </div>
    </div>

    <div class="game-container">
      <div class="hex-grid" id="hex-grid"></div>
    </div>

    <div class="game-status" id="game-status">
      Red player's turn - Place your titan
    </div>

    <div class="controls">
      <button id="reset-btn">Reset Game</button>
      <button id="pause-btn">Pause</button>
      <button id="undo-btn" class="secondary" disabled>Undo</button>
      <button id="redo-btn" class="secondary" disabled>Redo</button>
      <button id="sound-btn" class="secondary">Sound: ON</button>
      <button id="ai-btn" class="secondary">Play vs AI</button>
    </div>

    <div class="move-history">
      <h3 style="font-weight: bold;">Move History</h3>
      <div id="history-list"></div>
    </div>

    <audio
      id="place-sound"
      src="arcade jump.wav"
      preload="auto"
    ></audio>
    <audio
      id="move-sound"
      src="arcade move.wav"
      preload="auto"
    ></audio>
    <audio
      id="capture-sound"
      src="arcade capture.wav"
      preload="auto"
    ></audio>
    <audio
      id="eliminate-sound"
      src="arcade game over.wav"
      preload="auto"
    ></audio>

    <script>
      class TitanGame {
          constructor() {
              // Game constants
              this.EDGE_WEIGHTS = [1,1,1,1,1,1, 1,6,1,6,1,6, 8,9,8,9,8,9];
              this.TOTAL_TITANS = 4;
              this.TURN_TIME = 30; // seconds per turn
              this.GAME_TIME = 120; // seconds per player

              // DOM elements
              this.hexGrid = document.getElementById('hex-grid');
              this.playerRed = document.getElementById('player-red');
              this.playerBlue = document.getElementById('player-blue');
              this.timerRed = document.getElementById('timer-red');
              this.timerBlue = document.getElementById('timer-blue');
              this.scoreRed = document.getElementById('score-red');
              this.scoreBlue = document.getElementById('score-blue');
              this.titansRed = document.getElementById('titans-red');
              this.titansBlue = document.getElementById('titans-blue');
              this.gameStatus = document.getElementById('game-status');
              this.resetBtn = document.getElementById('reset-btn');
              this.pauseBtn = document.getElementById('pause-btn');
              this.undoBtn = document.getElementById('undo-btn');
              this.redoBtn = document.getElementById('redo-btn');
              this.soundBtn = document.getElementById('sound-btn');
              this.aiBtn = document.getElementById('ai-btn');
              this.historyList = document.getElementById('history-list');

              // Add start game button
              this.addStartGameButton();

              // Audio elements
              this.placeSound = document.getElementById('place-sound');
              this.moveSound = document.getElementById('move-sound');
              this.captureSound = document.getElementById('capture-sound');
              this.eliminateSound = document.getElementById('eliminate-sound');

              // Initialize game
              this.initGame();

              // Event listeners
              this.resetBtn.addEventListener('click', () => location.reload());
              this.pauseBtn.addEventListener('click', () => this.togglePause());
              this.undoBtn.addEventListener('click', () => this.undoMove());
              this.redoBtn.addEventListener('click', () => this.redoMove());
              this.soundBtn.addEventListener('click', () => this.toggleSound());
              this.aiBtn.addEventListener('click', () => this.toggleAIMode());
          }

          addStartGameButton() {
              const startBtn = document.createElement('button');
              startBtn.className = 'start-btn';
              startBtn.textContent = 'Start Game';
              startBtn.style.cssText = `
                  background-color: #4CAF50;
                  color: white;
                  padding: 15px 30px;
                  font-size: 18px;
                  margin: 20px 0;
              `;
              startBtn.addEventListener('click', () => this.startGame());
              document.querySelector('.controls').insertBefore(startBtn, document.querySelector('.controls').firstChild);
          }

          initGame() {
              // Game state
              this.state = {
                  currentPlayer: 'red',
                  phase: 'placement',
                  placedTitans: { red: 0, blue: 0 },
                  scores: { red: 0, blue: 0 },
                  timeLeft: { red: this.GAME_TIME, blue: this.GAME_TIME },
                  turnTimeLeft: this.TURN_TIME,
                  nodes: [],
                  edges: [],
                  controlledEdges: { red: [], blue: [] },
                  gameActive: false,
                  gamePaused: false,
                  soundEnabled: true,
                  aiMode: false,
                  aiPlayer: 'blue',
                  moveHistory: [],
                  historyIndex: -1,
                  selectedNode: null,
                  highlightedNodes: [],
                  doublePoints: false
              };

              // Clear the grid and history
              this.hexGrid.innerHTML = '';
              this.historyList.innerHTML = '';

              // Create the hexagonal grid
              this.createHexGrid();

              // Update UI
              this.updateUI();

              // Update status
              this.updateStatus('Click "Start Game" to begin');

              // Disable game controls
              this.pauseBtn.disabled = true;
              this.undoBtn.disabled = true;
              this.redoBtn.disabled = true;
          }

          startGame() {
              this.state.gameActive = true;
              this.pauseBtn.disabled = false;
              this.undoBtn.disabled = false;
              this.redoBtn.disabled = false;
              
              // Set initial player active state
              this.playerRed.classList.add('active');
              this.playerBlue.classList.remove('active');
              
              this.updateStatus(`${this.capitalize(this.state.currentPlayer)} player's turn - Place your titan`);
              this.startTimers();

              // If AI mode is on and AI is first player, make AI move
              if (this.state.aiMode && this.state.currentPlayer === this.state.aiPlayer) {
                  setTimeout(() => this.makeAIMove(), 1000);
              }
          }

          createHexGrid() {
              // Create three concentric hexagons
              const outerRadius = 200;
              const middleRadius = 130;
              const innerRadius = 60;
              const centerX = this.hexGrid.offsetWidth / 2;
              const centerY = this.hexGrid.offsetHeight / 2;

              // Create nodes for each circuit
              const outerNodes = this.createHexagonNodes(outerRadius, centerX, centerY, 'outer');
              const middleNodes = this.createHexagonNodes(middleRadius, centerX, centerY, 'middle');
              const innerNodes = this.createHexagonNodes(innerRadius, centerX, centerY, 'inner');

              // Combine all nodes
              this.state.nodes = [...outerNodes, ...middleNodes, ...innerNodes];

              // Create edges between nodes
              this.createEdges();
          }

          createHexagonNodes(radius, centerX, centerY, circuit) {
              const nodes = [];
              const angleStep = Math.PI / 3; // 60 degrees

              // Create 6 nodes for the hexagon
              for (let i = 0; i < 6; i++) {
                  const angle = i * angleStep;
                  const x = centerX + radius * Math.cos(angle);
                  const y = centerY + radius * Math.sin(angle);

                  const node = {
                      id: `${circuit}-${i}`,
                      x,
                      y,
                      circuit,
                      occupied: null,
                      element: null
                  };

                  nodes.push(node);

                  // Create DOM element for the node
                  const nodeElement = document.createElement('div');
                  nodeElement.className = 'hex-node';
                  nodeElement.style.left = `${x}px`;
                  nodeElement.style.top = `${y}px`;
                  nodeElement.dataset.id = node.id;

                  nodeElement.addEventListener('click', () => this.handleNodeClick(node));

                  this.hexGrid.appendChild(nodeElement);
                  node.element = nodeElement;
              }

              return nodes;
          }

          createEdges() {
              let edgeIndex = 0;

              // Only connect nodes within each circuit (hexagon sides)
              this.connectCircuitNodes('outer', edgeIndex);
              edgeIndex += 6;
              this.connectCircuitNodes('middle', edgeIndex);
              edgeIndex += 6;
              this.connectCircuitNodes('inner', edgeIndex);
              edgeIndex += 6;

              // Only connect corresponding nodes between circuits (radials)
              for (let i = 0; i < 6; i++) {
                  // Outer to middle
                  this.createEdgeBetweenNodes(
                      this.getNodeById(`outer-${i}`),
                      this.getNodeById(`middle-${i}`),
                      edgeIndex++
                  );
                  // Middle to inner
                  this.createEdgeBetweenNodes(
                      this.getNodeById(`middle-${i}`),
                      this.getNodeById(`inner-${i}`),
                      edgeIndex++
                  );
              }
          }

          connectCircuitNodes(circuit, startEdgeIndex) {
              for (let i = 0; i < 6; i++) {
                  const node1 = this.getNodeById(`${circuit}-${i}`);
                  const node2 = this.getNodeById(`${circuit}-${(i + 1) % 6}`);
                  this.createEdgeBetweenNodes(node1, node2, startEdgeIndex + i);
              }
          }

          createEdgeBetweenNodes(node1, node2, edgeIndex) {
              const dx = node2.x - node1.x;
              const dy = node2.y - node1.y;
              const length = Math.sqrt(dx * dx + dy * dy);
              const angle = Math.atan2(dy, dx) * 180 / Math.PI;

              const edge = {
                  id: `edge-${edgeIndex}`,
                  node1: node1.id,
                  node2: node2.id,
                  weight: this.EDGE_WEIGHTS[edgeIndex],
                  controlledBy: null,
                  element: null
              };

              this.state.edges.push(edge);

              // Create DOM element for the edge
              const edgeElement = document.createElement('div');
              edgeElement.className = 'hex-edge';
              edgeElement.style.width = `${length}px`;
              edgeElement.style.left = `${node1.x}px`;
              edgeElement.style.top = `${node1.y}px`;
              edgeElement.style.transform = `rotate(${angle}deg)`;
              edgeElement.dataset.id = edge.id;

              // Add weight label
              const weightElement = document.createElement('div');
              weightElement.className = 'edge-weight';
              weightElement.textContent = edge.weight;
              const midX = node1.x + dx / 2;
              const midY = node1.y + dy / 2;
              // Move label 20% closer to center
              const centerX = this.hexGrid.offsetWidth / 2;
              const centerY = this.hexGrid.offsetHeight / 2;
              const labelX = midX + (centerX - midX) * 0.2;
              const labelY = midY + (centerY - midY) * 0.2;
              weightElement.style.left = `${labelX}px`;
              weightElement.style.top = `${labelY}px`;

              this.hexGrid.appendChild(edgeElement);
              this.hexGrid.appendChild(weightElement);
              edge.element = edgeElement;
          }

          handleNodeClick(node) {
              if (!this.state.gameActive || this.state.gamePaused) return;

              // AI move if it's AI's turn
              if (this.state.aiMode && this.state.currentPlayer === this.state.aiPlayer) {
                  return;
              }

              if (this.state.phase === 'placement') {
                  this.handlePlacement(node);
              } else if (this.state.phase === 'movement') {
                  this.handleMovement(node);
              }
          }

          handlePlacement(node) {
              // Check if node is available for placement
              if (node.occupied !== null) return;

              // Place the titan
              node.occupied = this.state.currentPlayer;
              node.element.classList.add(this.state.currentPlayer);

              // Update placed titans count
              this.state.placedTitans[this.state.currentPlayer]++;

              // Check if all titans are placed
              if (this.state.placedTitans[this.state.currentPlayer] === this.TOTAL_TITANS) {
                  // Switch to movement phase if both players have placed all titans
                  if (this.state.placedTitans.red === this.TOTAL_TITANS && 
                      this.state.placedTitans.blue === this.TOTAL_TITANS) {
                      this.state.phase = 'movement';
                      this.updateStatus(`${this.capitalize(this.state.currentPlayer)} player's turn - Move your titan`);
                  }
              }

              // Save state for undo/redo
              this.saveState();

              // Add to history
              this.addToHistory(`placed titan at ${node.id}`);

              // Switch player
              this.switchPlayer();

              // Play sound
              this.playSound(this.placeSound);

              // Update UI
              this.updateUI();

              // Make AI move if in AI mode
              if (this.state.aiMode && this.state.currentPlayer === this.state.aiPlayer) {
                  setTimeout(() => this.makeAIMove(), 1000);
              }
          }

          handleMovement(node) {
              // If no node is selected, select this node if it belongs to current player
              if (!this.state.selectedNode) {
                  if (node.occupied === this.state.currentPlayer) {
                      this.state.selectedNode = node;
                      node.element.classList.add('selected');
                      
                      // Highlight valid moves
                      const validMoves = this.getValidMoves(node);
                      validMoves.forEach(move => {
                          move.element.classList.add('highlight');
                          this.state.highlightedNodes.push(move);
                      });
                      
                      this.updateStatus(`${this.capitalize(this.state.currentPlayer)} player - Select destination`);
                      return;
                  }
                  return;
              }

              // If a node is already selected, try to move to the clicked node
              if (this.state.selectedNode === node) {
                  // Deselect the node
                  this.state.selectedNode.element.classList.remove('selected');
                  this.state.selectedNode = null;
                  
                  // Remove highlights
                  this.state.highlightedNodes.forEach(node => {
                      node.element.classList.remove('highlight');
                  });
                  this.state.highlightedNodes = [];
                  
                  this.updateStatus(`${this.capitalize(this.state.currentPlayer)} player's turn - Move your titan`);
                  return;
              }

              // Check if the move is valid
              const validMoves = this.getValidMoves(this.state.selectedNode);
              if (!validMoves.includes(node)) {
                  return;
              }

              // Move the titan
              const oldNode = this.state.selectedNode;
              oldNode.occupied = null;
              oldNode.element.classList.remove(this.state.currentPlayer, 'selected');
              
              node.occupied = this.state.currentPlayer;
              node.element.classList.add(this.state.currentPlayer);

              // Remove highlights
              this.state.highlightedNodes.forEach(node => {
                  node.element.classList.remove('highlight');
              });
              this.state.highlightedNodes = [];
              this.state.selectedNode = null;

              // Check for edge control
              this.updateEdgeControl();

              // Check for titan elimination
              this.checkTitanElimination();

              // Save state for undo/redo
              this.saveState();

              // Add to history
              this.addToHistory(`moved titan from ${oldNode.id} to ${node.id}`);

              // Switch player
              this.switchPlayer();

              // Play sound
              this.playSound(this.moveSound);

              // Update UI
              this.updateUI();

              // Make AI move if in AI mode
              if (this.state.aiMode && this.state.currentPlayer === this.state.aiPlayer) {
                  setTimeout(() => this.makeAIMove(), 1000);
              }
          }

          getCurrentCircuit() {
              // Determine which circuit is currently unlocked for placement
              if (this.state.placedTitans.red < this.TOTAL_TITANS || 
                  this.state.placedTitans.blue < this.TOTAL_TITANS) {
                  return 'outer';
              }
              
              // Count occupied nodes in each circuit
              const outerCount = this.state.nodes.filter(n => n.circuit === 'outer' && n.occupied !== null).length;
              const middleCount = this.state.nodes.filter(n => n.circuit === 'middle' && n.occupied !== null).length;
              
              if (outerCount < 12) return 'outer';
              if (middleCount < 12) return 'middle';
              return 'inner';
          }

          getValidMoves(node) {
              const validMoves = [];
              
              // Get all edges connected to this node
              const connectedEdges = this.state.edges.filter(edge => 
                  edge.node1 === node.id || edge.node2 === node.id
              );
              
              // Check each connected node
              connectedEdges.forEach(edge => {
                  const connectedNodeId = edge.node1 === node.id ? edge.node2 : edge.node1;
                  const connectedNode = this.getNodeById(connectedNodeId);
                  
                  // Node is valid if it's empty
                  if (connectedNode.occupied === null) {
                      validMoves.push(connectedNode);
                  }
              });
              
              return validMoves;
          }

          updateEdgeControl() {
              // Reset all edge control
              this.state.edges.forEach(edge => {
                  edge.controlledBy = null;
                  edge.element.className = 'hex-edge';
              });
              
              // Check each edge for control
              this.state.edges.forEach(edge => {
                  const node1 = this.getNodeById(edge.node1);
                  const node2 = this.getNodeById(edge.node2);
                  
                  if (node1.occupied && node2.occupied && node1.occupied === node2.occupied) {
                      edge.controlledBy = node1.occupied;
                      edge.element.classList.add('controlled-edge', node1.occupied);
                      
                      // Update score
                      this.state.scores[node1.occupied] += edge.weight;
                  }
              });
          }

          checkTitanElimination() {
              this.state.nodes.forEach(node => {
                  if (node.occupied === null) return;
                  
                  const adjacentNodes = this.getAdjacentNodes(node);
                  const allAdjacentOccupied = adjacentNodes.every(adjNode => adjNode.occupied !== null);
                  const allAdjacentOpponent = adjacentNodes.every(adjNode => 
                      adjNode.occupied === this.getOpponentColor(node.occupied)
                  );
                  
                  if (allAdjacentOccupied && allAdjacentOpponent) {
                      // Eliminate the titan
                      node.occupied = null;
                      node.element.className = 'hex-node';
                      
                      // Update placed titans count
                      this.state.placedTitans[this.state.currentPlayer]--;
                      
                      // Play elimination sound
                      this.playSound(this.eliminateSound);
                      
                      // Add to history
                      this.addToHistory(`eliminated ${this.state.currentPlayer} titan at ${node.id}`);
                  }
              });
          }

          getAdjacentNodes(node) {
              const adjacentNodes = [];
              
              this.state.edges.forEach(edge => {
                  if (edge.node1 === node.id) {
                      adjacentNodes.push(this.getNodeById(edge.node2));
                  } else if (edge.node2 === node.id) {
                      adjacentNodes.push(this.getNodeById(edge.node1));
                  }
              });
              
              return adjacentNodes;
          }

          getOpponentColor(color) {
              return color === 'red' ? 'blue' : 'red';
          }

          toggleSound() {
              this.state.soundEnabled = !this.state.soundEnabled;
              this.soundBtn.textContent = `Sound: ${this.state.soundEnabled ? 'ON' : 'OFF'}`;
          }

          toggleAIMode() {
              this.state.aiMode = !this.state.aiMode;
              this.aiBtn.textContent = this.state.aiMode ? 'Play vs Human' : 'Play vs AI';
              this.aiBtn.classList.toggle('secondary', !this.state.aiMode);
              this.aiBtn.classList.toggle('danger', this.state.aiMode);

              // If game is active and it's AI's turn, make AI move
              if (this.state.gameActive && this.state.aiMode && 
                  this.state.currentPlayer === this.state.aiPlayer) {
                  setTimeout(() => this.makeAIMove(), 1000);
              }
          }

          playSound(soundElement) {
              if (this.state.soundEnabled) {
                  soundElement.currentTime = 0;
                  soundElement.play().catch(e => console.log("Audio play failed:", e));
              }
          }

          saveState() {
              // Clear any redo history
              this.state.moveHistory = this.state.moveHistory.slice(0, this.state.historyIndex + 1);

              // Create a deep copy of the current state
              const stateCopy = JSON.parse(JSON.stringify(this.state));

              // Remove circular references and DOM elements
              stateCopy.nodes = stateCopy.nodes.map(node => ({
                  ...node,
                  element: null
              }));

              stateCopy.edges = stateCopy.edges.map(edge => ({
                  ...edge,
                  element: null
              }));

              stateCopy.selectedNode = null;
              stateCopy.highlightedNodes = [];

              // Add to history
              this.state.moveHistory.push(stateCopy);
              this.state.historyIndex = this.state.moveHistory.length - 1;
          }

          undoMove() {
              if (this.state.historyIndex < 0) return;

              this.state.historyIndex--;
              this.restoreState();

              // Add to history
              this.addToHistory(`${this.capitalize(this.state.currentPlayer)} undid last move`);
          }

          redoMove() {
              if (this.state.historyIndex >= this.state.moveHistory.length - 1) return;

              this.state.historyIndex++;
              this.restoreState();

              // Add to history
              this.addToHistory(`${this.capitalize(this.state.currentPlayer)} redid move`);
          }

          restoreState() {
              if (this.state.historyIndex < 0) {
                  this.initGame();
                  return;
              }

              const savedState = this.state.moveHistory[this.state.historyIndex];

              // Restore basic state
              this.state.currentPlayer = savedState.currentPlayer;
              this.state.phase = savedState.phase;
              this.state.placedTitans = {...savedState.placedTitans};
              this.state.scores = {...savedState.scores};
              this.state.timeLeft = {...savedState.timeLeft};
              this.state.turnTimeLeft = savedState.turnTimeLeft;
              this.state.controlledEdges = {
                  red: [...savedState.controlledEdges.red],
                  blue: [...savedState.controlledEdges.blue]
              };
              this.state.gameActive = savedState.gameActive;
              this.state.gamePaused = savedState.gamePaused;
              this.state.selectedNode = null;
              this.state.highlightedNodes = [];

              // Restore nodes
              this.state.nodes.forEach(node => {
                  const savedNode = savedState.nodes.find(n => n.id === node.id);
                  if (savedNode) {
                      node.occupied = savedNode.occupied;
                      node.element.className = 'hex-node';
                      if (node.occupied) {
                          node.element.classList.add(node.occupied);
                      }
                  }
              });

              // Restore edges
              this.state.edges.forEach(edge => {
                  const savedEdge = savedState.edges.find(e => e.id === edge.id);
                  if (savedEdge) {
                      edge.controlledBy = savedEdge.controlledBy;
                      edge.element.className = 'hex-edge';
                      if (edge.controlledBy) {
                          edge.element.classList.add('controlled-edge', edge.controlledBy);
                      }
                  }
              });

              // Update UI
              this.updateUI();
              this.updateTimerDisplay();

              // Update player active state
              this.playerRed.classList.toggle('active', this.state.currentPlayer === 'red');
              this.playerBlue.classList.toggle('active', this.state.currentPlayer === 'blue');

              // Update status message
              if (this.state.phase === 'placement') {
                  this.updateStatus(`${this.capitalize(this.state.currentPlayer)} player's turn - Place your titan`);
              } else {
                  this.updateStatus(`${this.capitalize(this.state.currentPlayer)} player's turn - Move your titan`);
              }
          }

          addToHistory(message) {
              const moveItem = document.createElement('div');
              moveItem.className = 'move-item';

              const movePlayer = document.createElement('span');
              movePlayer.className = `move-player ${this.state.currentPlayer}`;
              movePlayer.textContent = `${this.capitalize(this.state.currentPlayer)}: `;

              const moveText = document.createElement('span');
              moveText.textContent = message;

              moveItem.appendChild(movePlayer);
              moveItem.appendChild(moveText);
              this.historyList.appendChild(moveItem);

              // Scroll to bottom
              this.historyList.scrollTop = this.historyList.scrollHeight;
          }

          getNodeById(id) {
              return this.state.nodes.find(node => node.id === id);
          }

          makeAIMove() {
              if (!this.state.gameActive || this.state.gamePaused || !this.state.aiMode ||
                  this.state.currentPlayer !== this.state.aiPlayer) {
                  return;
              }

              if (this.state.phase === 'placement') {
                  this.makeAIPlacement();
              } else {
                  this.makeAIMovement();
              }
          }

          makeAIPlacement() {
              // Find all valid placement nodes
              const validNodes = this.state.nodes.filter(node =>
                  node.occupied === null && node.circuit === 'outer'
              );

              if (validNodes.length === 0) return;

              // Simple AI: choose random valid node
              const randomIndex = Math.floor(Math.random() * validNodes.length);
              const chosenNode = validNodes[randomIndex];

              // Simulate click after delay
              setTimeout(() => {
                  this.handlePlacement(chosenNode);
              }, 800);
          }

          makeAIMovement() {
              // Get all AI's titans
              const aiTitans = this.state.nodes.filter(node =>
                  node.occupied === this.state.aiPlayer
              );

              if (aiTitans.length === 0) return;

              // Try to find a move that captures an edge
              for (const titan of aiTitans) {
                  const adjacentNodes = this.getAdjacentNodes(titan);
                  const emptyAdjacent = adjacentNodes.filter(node => node.occupied === null);

                  for (const target of emptyAdjacent) {
                      // Simulate the move
                      titan.occupied = null;
                      target.occupied = this.state.aiPlayer;

                      // Check if this move would capture any edges
                      const wouldCapture = this.state.edges.some(edge => {
                          const node1 = this.getNodeById(edge.node1);
                          const node2 = this.getNodeById(edge.node2);
                          return (edge.controlledBy !== this.state.aiPlayer) &&
                                 (node1.occupied === this.state.aiPlayer &&
                                  node2.occupied === this.state.aiPlayer);
                      });

                      // Undo the simulation
                      titan.occupied = this.state.aiPlayer;
                      target.occupied = null;

                      if (wouldCapture) {
                          // Found a good move - select and move
                          setTimeout(() => {
                              this.handleMovement(titan); // Select titan
                              setTimeout(() => {
                                  this.handleMovement(target); // Move to target
                              }, 500);
                          }, 800);
                          return;
                      }
                  }
              }

              // If no capturing move found, make a random move
              const randomTitanIndex = Math.floor(Math.random() * aiTitans.length);
              const randomTitan = aiTitans[randomTitanIndex];
              const adjacentNodes = this.getAdjacentNodes(randomTitan);
              const emptyAdjacent = adjacentNodes.filter(node => node.occupied === null);

              if (emptyAdjacent.length > 0) {
                  const randomTargetIndex = Math.floor(Math.random() * emptyAdjacent.length);
                  const randomTarget = emptyAdjacent[randomTargetIndex];

                  setTimeout(() => {
                      this.handleMovement(randomTitan); // Select titan
                      setTimeout(() => {
                          this.handleMovement(randomTarget); // Move to target
                      }, 500);
                  }, 800);
              }
          }

          switchPlayer() {
              this.state.currentPlayer = this.state.currentPlayer === 'red' ? 'blue' : 'red';
              
              // Update player info active state
              this.playerRed.classList.toggle('active', this.state.currentPlayer === 'red');
              this.playerBlue.classList.toggle('active', this.state.currentPlayer === 'blue');
              
              // Update status message
              if (this.state.phase === 'placement') {
                  this.updateStatus(`${this.capitalize(this.state.currentPlayer)} player's turn - Place your titan`);
              } else {
                  this.updateStatus(`${this.capitalize(this.state.currentPlayer)} player's turn - Move your titan`);
              }
              
              // Reset turn timer
              this.state.turnTimeLeft = this.TURN_TIME;
              this.updateTimerDisplay();
          }

          updateTimerDisplay() {
              const timeLeft = this.state.timeLeft[this.state.currentPlayer];
              const minutes = Math.floor(timeLeft / 60);
              const seconds = timeLeft % 60;
              this.timerRed.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
          }

          updateStatus(message) {
              const statusElement = document.getElementById('game-status');
              statusElement.textContent = message;
              
              // Update status color based on current player
              statusElement.className = 'game-status';
              if (this.state.gameActive) {
                  statusElement.classList.add(this.state.currentPlayer);
              }
          }

          updateUI() {
              this.state.nodes.forEach(node => {
                  node.element.className = 'hex-node';
                  if (node.occupied) {
                      node.element.classList.add(node.occupied);
                  }
              });

              this.state.edges.forEach(edge => {
                  edge.element.className = 'hex-edge';
                  if (edge.controlledBy) {
                      edge.element.classList.add('controlled-edge', edge.controlledBy);
                  }
              });
          }

          startTimers() {
              // Clear any existing timers
              if (this.gameTimer) clearInterval(this.gameTimer);
              if (this.turnTimer) clearInterval(this.turnTimer);

              // Start the game timer
              this.gameTimer = setInterval(() => {
                  if (!this.state.gameActive || this.state.gamePaused) return;

                  this.state.timeLeft[this.state.currentPlayer]--;
                  this.updateTimerDisplay();

                  // Check if time is up
                  if (this.state.timeLeft[this.state.currentPlayer] <= 0) {
                      this.endGame();
                  }
              }, 1000);

              // Start the turn timer
              this.turnTimer = setInterval(() => {
                  if (!this.state.gameActive || this.state.gamePaused) return;

                  this.state.turnTimeLeft--;
                  this.updateTurnTimerDisplay();

                  // Check if turn time is up
                  if (this.state.turnTimeLeft <= 0) {
                      this.switchPlayer();
                      this.state.turnTimeLeft = this.TURN_TIME;
                  }
              }, 1000);
          }

          updateTurnTimerDisplay() {
              const minutes = Math.floor(this.state.turnTimeLeft / 60);
              const seconds = this.state.turnTimeLeft % 60;
              const timerElement = this.state.currentPlayer === 'red' ? this.timerRed : this.timerBlue;
              timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
          }

          togglePause() {
              this.state.gamePaused = !this.state.gamePaused;
              this.pauseBtn.textContent = this.state.gamePaused ? 'Resume' : 'Pause';
              
              if (this.state.gamePaused) {
                  this.updateStatus('Game Paused');
              } else {
                  if (this.state.phase === 'placement') {
                      this.updateStatus(`${this.capitalize(this.state.currentPlayer)} player's turn - Place your titan`);
                  } else {
                      this.updateStatus(`${this.capitalize(this.state.currentPlayer)} player's turn - Move your titan`);
                  }
              }
          }

          endGame() {
              this.state.gameActive = false;
              clearInterval(this.gameTimer);
              clearInterval(this.turnTimer);

              // Remove active state from both players
              this.playerRed.classList.remove('active');
              this.playerBlue.classList.remove('active');

              // Determine winner
              let winner = 'red';
              if (this.state.scores.blue > this.state.scores.red) {
                  winner = 'blue';
              } else if (this.state.scores.blue === this.state.scores.red) {
                  winner = 'tie';
              }

              // Update status with winner color
              if (winner === 'tie') {
                  this.updateStatus('Game Over - It\'s a tie!');
              } else {
                  this.updateStatus(`Game Over - ${this.capitalize(winner)} player wins!`);
              }

              // Update leaderboard
              this.updateLeaderboard(winner);

              // Disable controls
              this.resetBtn.disabled = false;
              this.pauseBtn.disabled = true;
              this.undoBtn.disabled = true;
              this.redoBtn.disabled = true;
          }

          updateLeaderboard(winner) {
              // Get existing leaderboard
              let leaderboard = JSON.parse(localStorage.getItem('titansCircuitLeaderboard') || '[]');

              // Add new game result
              leaderboard.push({
                  date: new Date().toISOString(),
                  winner: winner,
                  redScore: this.state.scores.red,
                  blueScore: this.state.scores.blue,
                  duration: this.GAME_TIME * 2 - (this.state.timeLeft.red + this.state.timeLeft.blue)
              });

              // Sort by date (most recent first)
              leaderboard.sort((a, b) => new Date(b.date) - new Date(a.date));

              // Keep only last 10 games
              leaderboard = leaderboard.slice(0, 10);

              // Save to localStorage
              localStorage.setItem('titansCircuitLeaderboard', JSON.stringify(leaderboard));
          }

          capitalize(str) {
              return str.charAt(0).toUpperCase() + str.slice(1);
          }
      }

      // Initialize the game when the page loads
      document.addEventListener('DOMContentLoaded', () => {
          const game = new TitanGame();
      });
    </script>
  </body>
</html>
